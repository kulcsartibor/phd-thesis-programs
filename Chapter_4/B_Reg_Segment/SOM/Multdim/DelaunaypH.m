%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Delaunay model based control
%For pH process
%Identification and control
%%J. ABonyi, TUDelft, Control Lab. Nov. 1999
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all

global modelpar tri node par
load vpHs;
load vF;


%flags 
apriori=1;
gainconstr=1;
dnorm=1; %Data normalization flag
dnnode=21; %the number of the desired node

nf1=4;
nf2=4;


%___________________________________________
%pH data
load tndata %generated by datagen, sampling time 0.2!! %n
temp=data(:,2);
data(:,2)=data(:,1);
data(:,1)=temp;

pHmin=min(data(:,2));
pHmax=max(data(:,2));
Fmin=min(data(:,1));
Fmax=max(data(:,1));


%initial partitioning
a1=min(data(:,2)):(max(data(:,2))-min(data(:,2)))/(nf1-1):max(data(:,2));
a2=min(data(:,2)):(max(data(:,2))-min(data(:,2)))/(nf2-1):max(data(:,2)); %division on pH
a1=interp1(vpHs,vF,a1);
a1(1)=Fmin;
a1(nf1)=Fmax;
ystac=vpHs;
ustac=vF;
  
  
if dnorm
   data(:,1)=(data(:,1)-Fmin)./(Fmax-Fmin);
   a1=(a1-Fmin)./(Fmax-Fmin);
   data(:,2:3)=(data(:,2:3)-pHmin)./(pHmax-pHmin);
   a2=(a2-pHmin)./(pHmax-pHmin);
   ystac=(vpHs-pHmin)./(pHmax-pHmin);
   ustac=(vF-Fmin)./(Fmax-Fmin);
end

node=[];
flag=0;
for i=1:nf1
   if flag==0
    	%	node=[node; [a1(i)*ones(size([1:2:nf2],2),1) a2(1:2:nf2)']];
      %   node=[node; [a1(i)*ones(size([1:nf2],2),1) a2(1:nf2)']];
   	   flag=1;
   else
      % 	node=[node; [a1(i)*ones(size([2:2:nf2-1],2),1) a2(2:2:nf2-1)']];
      %  node=[node; [a1(i)*ones(size([1:nf2],2),1) a2(1:nf2)']];
	      flag=0;
   end
end
%node=[node; [a1(end) a2(end)]];

%Only on the borders!
node=[node; [a1(1)*ones(size([1:nf2],2),1) a2(1:nf2)']]; %top row
node=[node; [a1(end)*ones(size([1:nf2],2),1) a2(1:nf2)']]; %top row
node=[node; [a1(2:nf1-1)' a2(1)*ones(size([2:nf1-1],2),1) ]]; %left
node=[node; [a1(2:nf1-1)' a2(end)*ones(size([2:nf1-1],2),1) ]]; %right

%___________________________________________
%Clustring the data c-means or static node
if 0
   nc=5; %
	[center, U, obj_fcn] = fcv1(data(:,1:2), nc);
 	node=[node; [center(:,1) center(:,2)]];
   plot(node(:,1),node(:,2),'rd');
 else %User gerenated model
%   if dnorm
%      node=[node; [((interp1(vpHs,vF,[7.25:1:10.25]))'-Fmin)./(Fmax-Fmin) ([7.25:1:10.25]'-pHmin)./(pHmax-pHmin)]];
%   else
%      node=[node; [(interp1(vpHs,vF,[7.25:1:10.25]))' [7.25:1:10.25]']];
%   end
end

ndata=size(data,1);
nnode=size(node,1);


nnodei=size(node,1);
newnode=[];
AIC=[];

for nadd=1:dnnode-nnodei;
   node=[node; newnode];
   nnode=size(node,1);
%_______________________________________
%delaunay partitioning the input space 
tri = DELAUNAY(node(:,1),node(:,2)); 
ntri=size(tri,1); %number of the triangules
%_______________________________________
%Local weight of the models
modelpar=[];
for i=1:ntri;
   P=node(tri(i,:),:);  				%nodes of the triagule
   P=[P ones(3,1)];
   modelpar=[modelpar; [[i i i]' [1 2 3]' (inv(P)*eye(3))']];
end
%_____________________________________________________________________
%Consequent identification 
%Calculation of the rule weights
T=tsearch(node(:,1),node(:,2),tri,data(:,1),data(:,2)); %these are the active traingulars
w=zeros(ndata,nnode);
for i=1:ndata
   anode=tri(T(i),:); 					%vector of the actual nodes
   modindex=find(modelpar(:,1)==T(i));%the index of the active models
   w(i,anode)=(modelpar(modindex,3:end)*[data(i,1:2) 1]')';
end   
%Least squares identification
%QP!!
%Generating the constraint matrix

Ts=tsearch(node(:,1),node(:,2),tri,ustac,ystac); %these are stable simplices
K=(diff(ystac)./diff(ustac)); %the steady-state gains

A=[];
b=[];
Ks=[];
  
for i=1:ntri
   index=find(modelpar(:,1)==i); 	%Find the index of the verteces 
   anodes=tri(i,:);
   BetaT=modelpar(index,3:5)'; 
   
   %Check is it a stable model
   stabi=find(Ts==i);
   if isempty(stabi) %There is no stacioner data in the simpex
      flags=0;
   else
      flags=1;
   end

   
   %Monotonicity
   Constrain=[[-1 0]' [0 -1]' [0 0]']; %for the monotonicity
   
   %Lower
   rowv=zeros(2,nnode); %clear row vector
   rowv(:,anodes)=Constrain*BetaT; %lover constrain
   A=[A; rowv];
   b=[b; [-10^(-6) -10^(-6)]']; %for monotonicity %lover

   %Upper
   rowv=zeros(2,nnode); %clear row vector
   rowv(:,anodes)=-Constrain*BetaT; %upper constrain
   A=[A; rowv];
   if flags
      b=[b; [100 0.995]']; 
   else
      b=[b; [100 100]']; 
   end
   
    %Constrain on the static gain, if it is stable 
   if flags&gainconstr
      %obtain the local min and max gain
      Kmin=min(K(stabi));
      Kmax=max(K(stabi));
      rowv=zeros(2,nnode); %clear row vector
      Constrain=[[-1 -Kmin 0]; [1 Kmax 0]]; %min and max
      rowv(:,anodes)=Constrain*BetaT; %lover constrain
      A=[A; rowv];
      b=[b; [-Kmin Kmax]']; 
      Ks=[Ks; [Kmin Kmax]];
   end
    
end   
oH=2*w'*w;
oc=2*(-1*w'*data(:,3));
if apriori
   par=qp(oH,oc,[A],[b]);%,VLB,VUB
else
   par=w\data(:,3); 							
end

%Error calculation for node insertion
err=(data(:,3)-w*par).^2; 				%The a posteriori modelling error
errT=zeros(ntri,1);
nT=zeros(ntri,1);
for i=1:ndata
   errT(T(i))=err(i)+errT(T(i)); 
   nT(T(i))=1+nT(T(i));
end
Te=find(errT==max(errT)); 				%The index of the triangle with the biggest MSE
inder=find(T==Te); 						%The index of the data where the error is big
newnode=[sum(data(inder,1).*err(inder))/errT(Te)  sum(data(inder,2).*err(inder))/errT(Te)];
if dnorm
   errdn=((data(:,3).*(pHmax-pHmin)+pHmin)-((w*par).*(pHmax-pHmin)+pHmin)).^2; %Denormalizalt error
  else
    errdn=sum(err);
end     
	nnode=size(node,1);
	MSE(nadd)=sum(errdn)/ndata;
   AIC(nadd)=log((1+2*nnode/ndata)*MSE(nadd));
   
end %end of the model building 

%
%______________________________________________________
%End of the model building procedure

%Denormalization
if dnorm
	%Renormalization for the figures!
	node(:,1)=node(:,1).*(Fmax-Fmin)+Fmin;
	node(:,2)=node(:,2).*(pHmax-pHmin)+pHmin;
	data(:,1)=data(:,1)*(Fmax-Fmin)+Fmin;
	data(:,2:3)=data(:,2:3).*(pHmax-pHmin)+pHmin;
	par=par.*(pHmax-pHmin)+pHmin;
	%Local weigh of the models
	modelpar=[];
	for i=1:ntri;
   	P=node(tri(i,:),:);  				%nodes of the triagule
	   P=[P ones(3,1)];
   	modelpar=[modelpar; [[i i i]' [1 2 3]' (inv(P)*eye(3))']];
   end
   Ks=Ks*(pHmax-pHmin)/(Fmax-Fmin);
end

Ks

close all

figure(1) %plot the surface
TRISURF(tri,node(:,1),node(:,2),par',par');
hold on
plot3(data(:,1),data(:,2),data(:,3),'k.')   
colormap([1 1 1]);
xlabel('F_NaOH(k)');
ylabel('pH(k)');
zlabel('pH(k+1)');
hold off

pargen
sim('freerun');
plotfree
sim('imc');
plotres

print -f1 -deps cgsurf
print -f2 -deps cgpart
print -f3 -deps cgfree
print -f4 -deps cgcont

